<!doctype html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Reduce stale HTML caching that can cause blank screens on mobile after deploys -->
    <meta http-equiv="Cache-Control" content="no-store, max-age=0" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <!-- Some mobile browsers (notably iOS private mode) can throw on localStorage access.
         If that happens during auth/client init, the app can fail before React mounts.
         Patch Storage methods to fall back to in-memory storage instead of throwing. -->
    <script>
      (function () {
        function canUseStorage(s) {
          try {
            if (!s) return false;
            var k = "__regraph_storage_test__";
            s.setItem(k, "1");
            s.removeItem(k);
            return true;
          } catch (e) {
            return false;
          }
        }

        var okLocal = canUseStorage(window.localStorage);
        var okSession = canUseStorage(window.sessionStorage);
        if (okLocal && okSession) return;

        var memLocal = new Map();
        var memSession = new Map();

        function pick(thisArg) {
          try {
            if (thisArg === window.sessionStorage) return memSession;
          } catch (e) {
            // ignore
          }
          return memLocal;
        }

        function wrap(proto, name, fn) {
          try {
            var orig = proto[name];
            if (typeof orig !== "function") return;
            proto[name] = function () {
              try {
                return orig.apply(this, arguments);
              } catch (e) {
                return fn.apply(this, arguments);
              }
            };
          } catch (e) {
            // ignore
          }
        }

        try {
          var proto = window.Storage && window.Storage.prototype;
          if (!proto) return;

          wrap(proto, "getItem", function (key) {
            var m = pick(this);
            key = String(key);
            return m.has(key) ? m.get(key) : null;
          });
          wrap(proto, "setItem", function (key, value) {
            var m = pick(this);
            m.set(String(key), String(value));
          });
          wrap(proto, "removeItem", function (key) {
            var m = pick(this);
            m.delete(String(key));
          });
          wrap(proto, "clear", function () {
            pick(this).clear();
          });
          wrap(proto, "key", function (i) {
            var keys = Array.from(pick(this).keys());
            return keys[i] || null;
          });

          // Best-effort length getter fallback
          try {
            Object.defineProperty(proto, "length", {
              get: function () {
                try {
                  // If native works, prefer it
                  return Object.getOwnPropertyDescriptor(window.localStorage.__proto__, "length")?.get?.call(this);
                } catch (e) {
                  return pick(this).size;
                }
              },
              configurable: true,
            });
          } catch (e) {
            // ignore
          }

          window.__regraph_storage_fallback = true;
        } catch (e) {
          // ignore
        }
      })();
    </script>
    <title>ReGraph - Decentralized AI Compute Marketplace | 80% Cheaper Than Cloud</title>
    <meta name="description" content="Access 50+ AI models at up to 80% lower cost than AWS, Google Cloud & OpenAI. Decentralized GPU, TPU & NPU network for inference and training. OpenAI-compatible API." />
    <meta name="keywords" content="AI compute, decentralized AI, GPU marketplace, AI inference, machine learning, LLM API, GPT-5, Claude, Llama, cheap AI, distributed computing, GPU rental, AI training, neural network, crypto AI" />
    <meta name="author" content="ReGraph" />
    <meta name="robots" content="index, follow" />
    
    <!-- Preconnect to critical origins -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="preconnect" href="https://rwzyvgralronyuzqwyhu.supabase.co" />
    
    <!-- Load fonts asynchronously to prevent render blocking -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700;800&display=swap" media="print" onload="this.media='all'" />
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700;800&display=swap" /></noscript>
    
    

    <link rel="icon" type="image/png" href="/favicon.png" />
    <link rel="apple-touch-icon" href="/favicon.png" />

    <meta property="og:title" content="ReGraph - Decentralized AI Compute Marketplace" />
    <meta property="og:description" content="Access 50+ AI models at up to 80% lower cost. Decentralized GPU network for inference and training. OpenAI-compatible API." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://regraph.tech" />
    <meta property="og:image" content="https://regraph.tech/og-image.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="ReGraph" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@ReGraphAI" />
    <meta name="twitter:title" content="ReGraph - Decentralized AI Compute Marketplace" />
    <meta name="twitter:description" content="Access 50+ AI models at up to 80% lower cost. Decentralized GPU network for inference and training." />
    <meta name="twitter:image" content="https://regraph.tech/og-image.png" />
    
    <link rel="canonical" href="https://regraph.tech" />
  </head>

  <body>
    <!-- Boot spinner: visible until React mounts, then removed by App.tsx -->
    <div id="boot-spinner" aria-hidden="true"></div>


    <div id="root"></div>

    <!-- Main app script - must be BEFORE the watchdog so it's in DOM when watchdog runs -->
    <script id="boot-main" type="module" src="/src/main.tsx"></script>

    <!-- Recovery + diagnostics (designed to avoid reload loops, but still heal stale-module failures) -->
    <script>
      (function () {
        var MOUNT_FLAG = "__regraphMounted";
        var START_TS = Date.now();

        // Log early so Boot Events isn't empty when users report an infinite spinner.
        var SLOW_LOG_MS = 15000;
        // Show fatal UI after a minute (spinner shouldn't run forever).
        var FATAL_DEADLINE_MS = 60000;

        // Allow at most one automatic reload for recoverable stale-chunk/module errors.
        var RELOAD_PARAM = "__regraph_reload";

        // single event per page-load
        var sent = false;

        function now() {
          return Date.now();
        }

        function isMounted() {
          return !!window[MOUNT_FLAG];
        }

        function safeUrl() {
          try {
            return new URL(window.location.href);
          } catch (e) {
            return null;
          }
        }

        function hasReloadMarker() {
          try {
            return new URL(window.location.href).searchParams.has(RELOAD_PARAM);
          } catch (e) {
            return false;
          }
        }

        function isRecoverableModuleError(message) {
          var m = String(message || "").toLowerCase();
          return (
            m.indexOf("loading chunk") !== -1 ||
            m.indexOf("failed to fetch dynamically imported module") !== -1 ||
            m.indexOf("importing a module script failed") !== -1 ||
            m.indexOf("preload") !== -1
          );
        }

        function removeSpinner() {
          var el = document.getElementById("boot-spinner");
          if (el) el.remove();
        }

        function record(kind, detail) {
          try {
            localStorage.setItem(
              "__regraph_boot_diag",
              JSON.stringify({ t: now(), kind: String(kind || "unknown"), detail: String(detail || "") })
            );
          } catch (e) {
            // ignore
          }
        }

        function readDiag() {
          try {
            var raw = localStorage.getItem("__regraph_boot_diag");
            if (!raw) return null;
            return JSON.parse(raw);
          } catch (e) {
            return null;
          }
        }

        function sendBootEvent(reason, extraDiag) {
          if (sent) return;
          sent = true;
          try {
            var diag = readDiag();
            var baseDiag = diag && typeof diag === "object" ? diag : {};
            var extra = extraDiag && typeof extraDiag === "object" ? extraDiag : {};

            var payload = {
              reason: String(reason || "unknown"),
              url: window.location.href,
              userAgent: navigator.userAgent,
              diag: Object.assign({}, baseDiag, extra, {
                elapsedMs: now() - START_TS,
                mainLoaded: !!window.__regraphMainLoaded,
                path: window.location.pathname,
              }),
              storageFallback: !!window.__regraph_storage_fallback,
              attempts: hasReloadMarker() ? 1 : 0,
            };

            var url = "https://rwzyvgralronyuzqwyhu.supabase.co/functions/v1/log-boot-event";
            if (navigator.sendBeacon) {
              navigator.sendBeacon(url, JSON.stringify(payload));
            } else {
              fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
                keepalive: true,
              }).catch(function () {});
            }
          } catch (e) {
            // ignore
          }
        }

        // If the entry script never executed, DO NOT remove the spinner (black screen is worse).
        // Instead, probe whether the entry script URL is reachable:
        // - If unreachable (common after deploy + cached HTML), auto-reload once with cache-busting params.
        // - If reachable, treat as "slow start" and keep the spinner until React mounts or fatal deadline.
        setTimeout(function () {
          (function () {
            try {
              if (window.__regraphMainLoaded) return;

              var scriptEl = document.getElementById("boot-main");
              var src = scriptEl && scriptEl.getAttribute ? scriptEl.getAttribute("src") : null;

              // If we can't find a script src, log and allow the fatal UI to kick in.
              if (!src) {
                sendBootEvent("main_not_started", { stage: "progress", probe: "no_boot_main" });
                return;
              }

              // Probe with cache bypass to detect stale cached HTML pointing at missing hashed assets.
              var controller = typeof AbortController !== "undefined" ? new AbortController() : null;
              var timedOut = false;
              var t = setTimeout(function () {
                timedOut = true;
                try {
                  if (controller) controller.abort();
                } catch (e) {}
              }, 2500);

              var doFetch = function (method) {
                return fetch(src, {
                  method: method,
                  cache: "no-store",
                  signal: controller ? controller.signal : undefined,
                });
              };

              // HEAD is cheaper; some hosts may not support it, so fall back to GET.
              doFetch("HEAD")
                .catch(function () {
                  return doFetch("GET");
                })
                .then(function (res) {
                  clearTimeout(t);
                  if (window.__regraphMainLoaded) return;

                  var ok = !!(res && res.ok);
                  var status = res ? res.status : 0;

                  if (!ok) {
                    // Entry script is not reachable -> likely stale cache / missing build asset.
                    sendBootEvent("main_not_started", {
                      stage: "progress",
                      probe: "entry_fetch_not_ok",
                      entrySrc: src,
                      status: status,
                    });
                    reloadOnce("entry_fetch_status_" + String(status || "unknown"));
                    return;
                  }

                  // Reachable, but still not executing: likely slow parse/CPU or some runtime block.
                  sendBootEvent("main_slow_start", {
                    stage: "progress",
                    probe: timedOut ? "entry_fetch_timeout" : "entry_fetch_ok",
                    entrySrc: src,
                    status: status,
                  });
                })
                .catch(function (err) {
                  clearTimeout(t);
                  if (window.__regraphMainLoaded) return;
                  sendBootEvent("main_not_started", {
                    stage: "progress",
                    probe: "entry_fetch_error",
                    entrySrc: src,
                    message: String((err && err.message) || err || "fetch_error"),
                  });
                  reloadOnce("entry_fetch_error");
                });
            } catch (e) {
              // ignore
            }
          })();
        }, 2500);

        function reloadOnce(triggerReason) {
          if (hasReloadMarker()) return;
          var u = safeUrl();
          if (!u) return;

          try {
            sendBootEvent("reload_once", { stage: "reload", trigger: String(triggerReason || "unknown") });
          } catch (e) {}

          u.searchParams.set(RELOAD_PARAM, "1");
          u.searchParams.set("__reload", String(now()));

          try {
            window.location.replace(u.toString());
          } catch (e) {
            window.location.href = u.toString();
          }
        }

        // Record + heal recoverable module/chunk failures
        window.addEventListener("error", function (e) {
          var msg = (e && (e.message || (e.error && e.error.message))) || "unknown";
          record("error", msg);

          if (isRecoverableModuleError(msg)) {
            reloadOnce("error:" + msg);
          } else {
            // non-recoverable: log immediately so admins see it
            sendBootEvent("boot_error", { stage: "error", message: String(msg) });
          }
        });

        window.addEventListener("unhandledrejection", function (e) {
          var reason = (e && e.reason) || "unknown";
          var msg = reason && reason.message ? reason.message : String(reason);
          record("rejection", msg);

          if (isRecoverableModuleError(msg)) {
            reloadOnce("rejection:" + msg);
          } else {
            sendBootEvent("boot_rejection", { stage: "rejection", message: String(msg) });
          }
        });

        function showFatalScreen(reason) {
          removeSpinner();
          // Ensure we always have a Boot Event in persistent failures
          sendBootEvent(reason, { stage: "fatal" });

          try {
            if (document.getElementById("boot-fatal")) return;

            var box = document.createElement("div");
            box.id = "boot-fatal";
            box.setAttribute("role", "alert");
            box.style.cssText =
              "position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10000;padding:24px;background:rgba(0,0,0,0.92);color:#fff;font-family:system-ui,-apple-system,sans-serif;";

            var card = document.createElement("div");
            card.style.cssText =
              "max-width:480px;width:100%;border:1px solid rgba(255,255,255,0.15);border-radius:16px;padding:24px;background:rgba(18,18,18,0.98);";

            var h = document.createElement("div");
            h.textContent = "Loading taking too long";
            h.style.cssText = "font-weight:700;font-size:20px;margin-bottom:12px;";

            var p = document.createElement("div");
            p.textContent = "The app did not start. Try refreshing. If it keeps failing, stale cached files may be blocking module loading.";
            p.style.cssText = "line-height:1.5;font-size:14px;opacity:0.85;margin-bottom:16px;";

            var btn = document.createElement("button");
            btn.type = "button";
            btn.textContent = "Refresh Page";
            btn.style.cssText =
              "appearance:none;border:0;border-radius:10px;padding:12px 20px;background:hsl(var(--primary));color:hsl(var(--primary-foreground));font-weight:600;font-size:15px;cursor:pointer;";
            btn.onclick = function () {
              window.location.reload();
            };

            card.appendChild(h);
            card.appendChild(p);
            card.appendChild(btn);
            box.appendChild(card);
            document.body.appendChild(box);
          } catch (e) {
            removeSpinner();
          }
        }

        // After 15s without mount, emit a "slow" boot event so admins can see it.
        setTimeout(function () {
          if (!isMounted()) {
            sendBootEvent("slow_mount", { stage: "progress" });
          }
        }, SLOW_LOG_MS);

        // After 60s, show fatal UI (no infinite spinner).
        setTimeout(function () {
          if (!isMounted()) showFatalScreen("deadline");
        }, FATAL_DEADLINE_MS);
      })();
    </script>

    <style>
      /* Boot spinner styles - shown until React mounts */
      :root{
        --primary:270 80% 60%;
        --boot-bg:240 10% 4%;
      }
      body{margin:0;background:hsl(var(--boot-bg));}
      #boot-spinner{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:9999;background:hsl(var(--boot-bg));}
      #boot-spinner:before{content:"";width:24px;height:24px;border-radius:999px;border:2px solid hsl(var(--primary) / 0.2);border-top-color:hsl(var(--primary));animation:bootspin 900ms linear infinite;}
      @keyframes bootspin{to{transform:rotate(360deg);}}
    </style>
  </body>
</html>
