<!doctype html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Reduce stale HTML caching that can cause blank screens on mobile after deploys -->
    <meta http-equiv="Cache-Control" content="no-store, max-age=0" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <!-- Some mobile browsers (notably iOS private mode) can throw on localStorage access.
         If that happens during auth/client init, the app can fail before React mounts.
         Patch Storage methods to fall back to in-memory storage instead of throwing. -->
    <script>
      (function () {
        function canUseStorage(s) {
          try {
            if (!s) return false;
            var k = "__regraph_storage_test__";
            s.setItem(k, "1");
            s.removeItem(k);
            return true;
          } catch (e) {
            return false;
          }
        }

        var okLocal = canUseStorage(window.localStorage);
        var okSession = canUseStorage(window.sessionStorage);
        if (okLocal && okSession) return;

        var memLocal = new Map();
        var memSession = new Map();

        function pick(thisArg) {
          try {
            if (thisArg === window.sessionStorage) return memSession;
          } catch (e) {
            // ignore
          }
          return memLocal;
        }

        function wrap(proto, name, fn) {
          try {
            var orig = proto[name];
            if (typeof orig !== "function") return;
            proto[name] = function () {
              try {
                return orig.apply(this, arguments);
              } catch (e) {
                return fn.apply(this, arguments);
              }
            };
          } catch (e) {
            // ignore
          }
        }

        try {
          var proto = window.Storage && window.Storage.prototype;
          if (!proto) return;

          wrap(proto, "getItem", function (key) {
            var m = pick(this);
            key = String(key);
            return m.has(key) ? m.get(key) : null;
          });
          wrap(proto, "setItem", function (key, value) {
            var m = pick(this);
            m.set(String(key), String(value));
          });
          wrap(proto, "removeItem", function (key) {
            var m = pick(this);
            m.delete(String(key));
          });
          wrap(proto, "clear", function () {
            pick(this).clear();
          });
          wrap(proto, "key", function (i) {
            var keys = Array.from(pick(this).keys());
            return keys[i] || null;
          });

          // Best-effort length getter fallback
          try {
            Object.defineProperty(proto, "length", {
              get: function () {
                try {
                  // If native works, prefer it
                  return Object.getOwnPropertyDescriptor(window.localStorage.__proto__, "length")?.get?.call(this);
                } catch (e) {
                  return pick(this).size;
                }
              },
              configurable: true,
            });
          } catch (e) {
            // ignore
          }

          window.__regraph_storage_fallback = true;
        } catch (e) {
          // ignore
        }
      })();
    </script>
    <title>ReGraph - Decentralized AI Compute Marketplace | 80% Cheaper Than Cloud</title>
    <meta name="description" content="Access 50+ AI models at up to 80% lower cost than AWS, Google Cloud & OpenAI. Decentralized GPU, TPU & NPU network for inference and training. OpenAI-compatible API." />
    <meta name="keywords" content="AI compute, decentralized AI, GPU marketplace, AI inference, machine learning, LLM API, GPT-5, Claude, Llama, cheap AI, distributed computing, GPU rental, AI training, neural network, crypto AI" />
    <meta name="author" content="ReGraph" />
    <meta name="robots" content="index, follow" />
    
    <!-- Preconnect to critical origins -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="preconnect" href="https://rwzyvgralronyuzqwyhu.supabase.co" />
    
    <!-- Load fonts asynchronously to prevent render blocking -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700;800&display=swap" media="print" onload="this.media='all'" />
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700;800&display=swap" /></noscript>
    
    

    <link rel="icon" type="image/png" href="/favicon.png" />
    <link rel="apple-touch-icon" href="/favicon.png" />

    <meta property="og:title" content="ReGraph - Decentralized AI Compute Marketplace" />
    <meta property="og:description" content="Access 50+ AI models at up to 80% lower cost. Decentralized GPU network for inference and training. OpenAI-compatible API." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://regraph.tech" />
    <meta property="og:image" content="https://regraph.tech/og-image.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="ReGraph" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@ReGraphAI" />
    <meta name="twitter:title" content="ReGraph - Decentralized AI Compute Marketplace" />
    <meta name="twitter:description" content="Access 50+ AI models at up to 80% lower cost. Decentralized GPU network for inference and training." />
    <meta name="twitter:image" content="https://regraph.tech/og-image.png" />
    
    <link rel="canonical" href="https://regraph.tech" />
    
    <!-- NOTE: Avoid custom modulepreload injection here. If the entry script fails,
         it is almost always an origin/CDN caching or content-type issue, not a missing preload. -->
  </head>

  <body>
    <!-- Boot spinner: visible until React mounts, then removed by App.tsx -->
    <div id="boot-spinner" aria-hidden="true"></div>


    <div id="root"></div>

    <!-- Main app script - must be BEFORE the watchdog so it's in DOM when watchdog runs -->
    <script id="boot-main" type="module" src="/src/main.tsx"></script>

    <!-- Recovery + diagnostics (designed to avoid reload loops, but still heal stale-module failures) -->
    <script>
      (function () {
        var MOUNT_FLAG = "__regraphMounted";
        var START_TS = Date.now();

        // Log early so Boot Events isn't empty when users report an infinite spinner.
        var SLOW_LOG_MS = 15000;
        // Show fatal UI after a minute (spinner shouldn't run forever).
        var FATAL_DEADLINE_MS = 60000;

        // Allow at most one automatic reload for recoverable stale-chunk/module errors.
        var RELOAD_PARAM = "__regraph_reload";

        // Allow multiple events per page-load, but de-dupe per reason and cap total.
        var sentReasons = Object.create(null);
        var sentCount = 0;

        function now() {
          return Date.now();
        }

        function isMounted() {
          return !!window[MOUNT_FLAG];
        }

        function safeUrl() {
          try {
            return new URL(window.location.href);
          } catch (e) {
            return null;
          }
        }

        function hasReloadMarker() {
          try {
            return new URL(window.location.href).searchParams.has(RELOAD_PARAM);
          } catch (e) {
            return false;
          }
        }

        function isRecoverableModuleError(message) {
          var m = String(message || "").toLowerCase();
          return (
            m.indexOf("loading chunk") !== -1 ||
            m.indexOf("failed to fetch dynamically imported module") !== -1 ||
            m.indexOf("importing a module script failed") !== -1 ||
            m.indexOf("preload") !== -1
          );
        }

        function removeSpinner() {
          var el = document.getElementById("boot-spinner");
          if (el) el.remove();
        }

        function record(kind, detail) {
          try {
            localStorage.setItem(
              "__regraph_boot_diag",
              JSON.stringify({ t: now(), kind: String(kind || "unknown"), detail: String(detail || "") })
            );
          } catch (e) {
            // ignore
          }
        }

        function readDiag() {
          try {
            var raw = localStorage.getItem("__regraph_boot_diag");
            if (!raw) return null;
            return JSON.parse(raw);
          } catch (e) {
            return null;
          }
        }

         function getBootLogUrls() {
           // IMPORTANT: keep both options.
           // Some mobile networks/content-blockers may block direct backend calls;
           // while sometimes the API gateway route may be misconfigured.
           var direct = "https://rwzyvgralronyuzqwyhu.supabase.co/functions/v1/log-boot-event";
           var gateway = "https://api.regraph.tech/v1/log-boot-event";
           try {
             var h = String(window.location.hostname || "");
             if (h === "regraph.tech" || /(^|\.)regraph\.tech$/i.test(h)) {
               // Prefer direct first (historically reliable), then gateway as fallback.
               return [direct, gateway];
             }
           } catch (e) {
             // ignore
           }
           // Non-prod/preview: direct only.
           return [direct];
         }

         function sendBootEvent(reason, extraDiag) {
          try {
            var key = String(reason || "unknown");
            if (sentReasons[key]) return;
            if (sentCount >= 6) return;
            sentReasons[key] = true;
            sentCount++;
          } catch (e) {
            // ignore
          }
          try {
            var diag = readDiag();
            var baseDiag = diag && typeof diag === "object" ? diag : {};
            var extra = extraDiag && typeof extraDiag === "object" ? extraDiag : {};

            // Include import log if available
            var importLog = null;
            try {
              var raw = localStorage.getItem("__regraph_import_log");
              if (raw) importLog = JSON.parse(raw);
            } catch (e) {}

            var payload = {
              reason: String(reason || "unknown"),
              url: window.location.href,
              userAgent: navigator.userAgent,
              diag: Object.assign({}, baseDiag, extra, {
                elapsedMs: now() - START_TS,
                mainLoaded: !!window.__regraphMainLoaded,
                bootStage: window.__regraphBootStage || null,
                path: window.location.pathname,
                importLog: importLog,
              }),
              storageFallback: !!window.__regraph_storage_fallback,
              attempts: hasReloadMarker() ? 1 : 0,
            };

             var urls = getBootLogUrls();
             var body = JSON.stringify(payload);

             for (var i = 0; i < (urls ? urls.length : 0); i++) {
               var url = urls[i];
               if (!url) continue;

               if (navigator.sendBeacon) {
                 // Safari can return false (or silently drop) when payload is too large.
                 // Fall back to keepalive fetch for reliability.
                 var ok = false;
                 try {
                   ok = navigator.sendBeacon(url, body);
                 } catch (e) {
                   ok = false;
                 }
                 if (ok) return;
               }

               try {
                 fetch(url, {
                   method: "POST",
                   headers: { "Content-Type": "application/json" },
                   body: body,
                   keepalive: true,
                 }).catch(function () {});
                 // If fetch is scheduled successfully, stop trying more URLs.
                 return;
               } catch (e) {
                 // try next url
               }
             }
          } catch (e) {
            // ignore
          }
        }

        // If the entry script never executed, DO NOT remove the spinner (black screen is worse).
        // Instead, probe whether the entry script URL is reachable:
        // - If unreachable (common after deploy + cached HTML), auto-reload once with cache-busting params.
        // - If reachable, treat as "slow start" and keep the spinner until React mounts or fatal deadline.
        setTimeout(function () {
          (function () {
            try {
              if (window.__regraphMainLoaded) return;

              function getEntryScriptSrc() {
                // Prefer our explicit marker if it survives the build pipeline.
                try {
                  var boot = document.getElementById("boot-main");
                  if (boot) {
                    var bootSrc =
                      (boot.getAttribute && boot.getAttribute("src")) ||
                      (boot.src ? String(boot.src) : null);
                    if (bootSrc) {
                      return { src: bootSrc, via: "boot-main" };
                    }
                    return { src: null, via: "boot-main-no-src" };
                  }
                } catch (e) {
                  // ignore
                }

                // Fallback: find the first module script with a src.
                try {
                  var moduleScripts = document.querySelectorAll('script[type="module"][src]');
                  if (moduleScripts && moduleScripts.length) {
                    var el = moduleScripts[0];
                    var s =
                      (el.getAttribute && el.getAttribute("src")) ||
                      (el.src ? String(el.src) : null);
                    if (s) {
                      return { src: s, via: "querySelector-module" };
                    }
                  }
                } catch (e) {
                  // ignore
                }

                // Last resort: iterate document.scripts (some browsers are pickier with querySelector).
                try {
                  var list = document.scripts;
                  for (var i = 0; i < (list ? list.length : 0); i++) {
                    var sEl = list[i];
                    if (!sEl) continue;
                    var t = (sEl.getAttribute && sEl.getAttribute("type")) || sEl.type;
                    if (String(t || "").toLowerCase() !== "module") continue;
                    var ss =
                      (sEl.getAttribute && sEl.getAttribute("src")) ||
                      (sEl.src ? String(sEl.src) : null);
                    if (ss) {
                      return { src: ss, via: "document.scripts" };
                    }
                  }
                } catch (e) {
                  // ignore
                }

                return { src: null, via: "not_found" };
              }

              var found = getEntryScriptSrc();
              var src = found && found.src ? String(found.src) : null;

              // If we can't find an entry script src, log and allow the fatal UI to kick in.
              if (!src) {
                sendBootEvent("main_not_started", {
                  stage: "progress",
                  probe: "no_entry_script",
                  via: found ? found.via : "unknown",
                });
                // If HTML is stale/malformed enough that we can't locate the entry script,
                // a single cache-busting reload is the safest self-heal.
                reloadOnce("no_entry_script");
                return;
              }

              // Probe with cache bypass to detect stale cached HTML pointing at missing hashed assets.
              // IMPORTANT: Some networks/devices are simply slow. Aborting too aggressively can
              // create a self-inflicted reload loop (especially on Safari). Use a more forgiving
              // timeout and never auto-reload on a probe timeout.
              var controller = typeof AbortController !== "undefined" ? new AbortController() : null;
              var timedOut = false;
              var PROBE_TIMEOUT_MS = 8000;
              var t = setTimeout(function () {
                timedOut = true;
                try {
                  if (controller) controller.abort();
                } catch (e) {}
              }, PROBE_TIMEOUT_MS);

              function withProbeParam(u) {
                try {
                  // Ensure the probe never hits a cached response.
                  var sep = u.indexOf("?") === -1 ? "?" : "&";
                  return u + sep + "__probe=" + String(now());
                } catch (e) {
                  return u;
                }
              }

               function injectModuleScript(u, label) {
                try {
                  if (document.getElementById("boot-main-retry")) return;
                  var s = document.createElement("script");
                  s.id = "boot-main-retry";
                  s.type = "module";
                  s.src = withProbeParam(u);
                  // In case the browser blocks/errs, capture it.
                  s.onerror = function () {
                     sendBootEvent("entry_script_error", {
                      stage: "retry",
                      label: String(label || "retry"),
                      entrySrc: String(u || ""),
                    });

                     // Extra: probe the same URL to capture status + content-type.
                     // This helps differentiate:
                     // - 404 missing hashed asset (stale cached HTML)
                     // - HTML served instead of JS (CDN error/challenge page)
                     // - wrong content-type
                     try {
                       var probeUrl = withProbeParam(String(u || ""));
                       fetch(probeUrl, { method: "GET", cache: "no-store" })
                         .then(function (res) {
                           var ct = null;
                           try {
                             ct = res && res.headers ? res.headers.get("content-type") : null;
                           } catch (e) {
                             ct = null;
                           }

                           // Read a small snippet; ignore errors.
                           return res
                             .text()
                             .then(function (txt) {
                               var snippet = String(txt || "").slice(0, 220);
                               sendBootEvent("entry_script_probe", {
                                 stage: "retry",
                                 label: String(label || "retry"),
                                 entrySrc: String(u || ""),
                                 probeStatus: res ? res.status : 0,
                                 probeOk: !!(res && res.ok),
                                 contentType: ct,
                                 snippet: snippet,
                               });

                                // Probe entry script dependencies (the most common cause of
                                // "Importing a module script failed" is a nested import failing).
                                // We extract Vite's dependency map from the fetched entry script.
                                try {
                                  var text = String(txt || "");
                                  var deps = null;

                                  function extractDeps(jsText) {
                                    try {
                                      // Vite output typically contains: m.f||(m.f=["assets/...js", ...])
                                      var m = jsText.match(
                                        /m\\.f\s*\|\|\s*\(m\\.f\s*=\s*(\[[^\]]+\])\)/
                                      );
                                      if (!m) {
                                        // Fallback: any direct assignment m.f=[...]
                                        m = jsText.match(/m\\.f\s*=\s*(\[[^\]]+\])/);
                                      }
                                      if (m && m[1]) {
                                        // First try JSON.parse (best case)
                                        try {
                                          var parsed = JSON.parse(m[1]);
                                          if (parsed && parsed.length) return parsed;
                                        } catch (e) {
                                          // ignore, fall through
                                        }

                                        // Fallback: extract quoted strings from within the array literal
                                        try {
                                          var list = [];
                                          var re = /\"([^\"]+)\"/g;
                                          var mm;
                                          while ((mm = re.exec(m[1]))) {
                                            list.push(mm[1]);
                                          }
                                          if (list.length) return list;
                                        } catch (e) {
                                          // ignore
                                        }
                                      }

                                      // Last resort: scan for common asset paths anywhere in the entry
                                      try {
                                        var hits = jsText.match(/\"assets\/[^"]+\.js\"/g);
                                        if (!hits || !hits.length) return null;
                                        var uniq = {};
                                        var out = [];
                                        for (var i = 0; i < hits.length; i++) {
                                          var s = String(hits[i] || "");
                                          s = s.replace(/^\"|\"$/g, "");
                                          if (!uniq[s]) {
                                            uniq[s] = true;
                                            out.push(s);
                                          }
                                          if (out.length >= 24) break;
                                        }
                                        return out.length ? out : null;
                                      } catch (e) {
                                        return null;
                                      }
                                    } catch (e) {
                                      return null;
                                    }
                                  }

                                  deps = extractDeps(text);

                                  if (!deps || !deps.length) {
                                    // Always log why deps probe didn't run so we can iterate.
                                    sendBootEvent("entry_deps_probe", {
                                      stage: "retry",
                                      label: String(label || "retry"),
                                      entrySrc: String(u || ""),
                                      probeError: "deps_not_extracted",
                                      // include a tiny hint (do not bloat payload)
                                      snippet: String(text || "").slice(0, 240),
                                    });
                                  } else {
                                    var maxDeps = 10;
                                    var list = deps.slice(0, maxDeps);

                                    function normalizeDepPath(p) {
                                      p = String(p || "");
                                      if (!p) return null;
                                      // Vite deps are often like "assets/foo.js".
                                      if (p[0] === "/") return p;
                                      if (p.indexOf("assets/") === 0) return "/" + p;
                                      return p;
                                    }

                                    function probeDep(depPath) {
                                      return new Promise(function (resolve) {
                                        try {
                                          var dep = normalizeDepPath(depPath);
                                          if (!dep) return resolve({ dep: String(depPath || ""), ok: false, status: 0, contentType: null });

                                          var depUrl = withProbeParam(dep);
                                          fetch(depUrl, { method: "GET", cache: "no-store" })
                                            .then(function (r) {
                                              var depCt = null;
                                              try {
                                                depCt = r && r.headers ? r.headers.get("content-type") : null;
                                              } catch (e) {
                                                depCt = null;
                                              }
                                              // Only read a snippet when the response is suspicious.
                                              var suspicious = !r.ok || (depCt && String(depCt).toLowerCase().indexOf("text/html") !== -1);
                                              if (!suspicious) {
                                                resolve({ dep: dep, ok: true, status: r.status, contentType: depCt });
                                                return;
                                              }
                                              r.text()
                                                .then(function (t2) {
                                                  resolve({
                                                    dep: dep,
                                                    ok: !!r.ok,
                                                    status: r.status,
                                                    contentType: depCt,
                                                    snippet: String(t2 || "").slice(0, 140),
                                                  });
                                                })
                                                .catch(function () {
                                                  resolve({ dep: dep, ok: !!r.ok, status: r.status, contentType: depCt, snippet: null });
                                                });
                                            })
                                            .catch(function (e) {
                                              resolve({ dep: dep, ok: false, status: 0, contentType: null, error: String((e && e.message) || e || "fetch_error") });
                                            });
                                        } catch (e) {
                                          resolve({ dep: String(depPath || ""), ok: false, status: 0, contentType: null, error: "probe_exception" });
                                        }
                                      });
                                    }

                                    Promise.all(list.map(probeDep))
                                      .then(function (results) {
                                        try {
                                          sendBootEvent("entry_deps_probe", {
                                            stage: "retry",
                                            label: String(label || "retry"),
                                            entrySrc: String(u || ""),
                                            deps: list,
                                            results: results,
                                          });

                                          // Self-heal: if any dependency is clearly wrong, do one cache-busting reload.
                                          if (!hasReloadMarker()) {
                                            for (var i = 0; i < results.length; i++) {
                                              var rr = results[i];
                                              var rct = rr && rr.contentType ? String(rr.contentType).toLowerCase() : "";
                                              var isHtml2 = rct.indexOf("text/html") !== -1;
                                              if ((rr && rr.status === 404) || isHtml2 || rr.ok === false) {
                                                reloadOnce("dep_probe");
                                                break;
                                              }
                                            }
                                          }
                                        } catch (e) {
                                          // ignore
                                        }
                                      })
                                      .catch(function (e) {
                                        sendBootEvent("entry_deps_probe", {
                                          stage: "retry",
                                          label: String(label || "retry"),
                                          entrySrc: String(u || ""),
                                          probeError: String((e && e.message) || e || "deps_probe_error"),
                                        });
                                      });
                                  }
                                } catch (e) {
                                  // ignore
                                }

                               // If we clearly got the wrong thing, try one controlled reload.
                               if (!hasReloadMarker()) {
                                 var isHtml = ct && String(ct).toLowerCase().indexOf("text/html") !== -1;
                                 if ((res && res.status === 404) || isHtml) {
                                   reloadOnce("entry_script_probe");
                                 }
                               }
                             })
                             .catch(function () {
                               sendBootEvent("entry_script_probe", {
                                 stage: "retry",
                                 label: String(label || "retry"),
                                 entrySrc: String(u || ""),
                                 probeStatus: res ? res.status : 0,
                                 probeOk: !!(res && res.ok),
                                 contentType: ct,
                                 snippet: null,
                               });
                             });
                         })
                         .catch(function (err) {
                           sendBootEvent("entry_script_probe", {
                             stage: "retry",
                             label: String(label || "retry"),
                             entrySrc: String(u || ""),
                             probeError: String((err && err.message) || err || "fetch_error"),
                           });
                         });
                     } catch (e) {
                       // ignore
                     }
                  };
                  // Note: load for scripts happens after fetch+evaluate.
                  s.onload = function () {
                    sendBootEvent("entry_script_loaded", {
                      stage: "retry",
                      label: String(label || "retry"),
                      entrySrc: String(u || ""),
                    });
                  };
                  (document.head || document.documentElement || document.body).appendChild(s);
                } catch (e) {
                  // ignore
                }
              }

              var doFetch = function (method) {
                return fetch(withProbeParam(src), {
                  method: method,
                  cache: "no-store",
                  signal: controller ? controller.signal : undefined,
                });
              };

              // HEAD is cheaper; some hosts may not support it, so fall back to GET.
              doFetch("HEAD")
                .catch(function () {
                  return doFetch("GET");
                })
                .then(function (res) {
                  clearTimeout(t);
                  if (window.__regraphMainLoaded) return;

                  var ok = !!(res && res.ok);
                  var status = res ? res.status : 0;
                  var contentType = null;
                  try {
                    contentType = res && res.headers ? res.headers.get("content-type") : null;
                  } catch (e) {
                    contentType = null;
                  }

                  if (!ok) {
                    // Entry script is not reachable -> likely stale cache / missing build asset.
                    sendBootEvent("main_not_started", {
                      stage: "progress",
                      probe: "entry_fetch_not_ok",
                      via: found ? found.via : "unknown",
                      entrySrc: src,
                      status: status,
                      contentType: contentType,
                    });
                    reloadOnce("entry_fetch_status_" + String(status || "unknown"));
                    return;
                  }

                  // Reachable, but still not executing: likely slow parse/CPU or some runtime block.
                  sendBootEvent("main_slow_start", {
                    stage: "progress",
                    probe: timedOut ? "entry_fetch_timeout" : "entry_fetch_ok",
                    via: found ? found.via : "unknown",
                    entrySrc: src,
                    status: status,
                    contentType: contentType,
                  });

                  // If we can fetch the entry but it still hasn't executed, try re-injecting it once.
                  // This helps in cases where iOS Safari gets stuck with an initial module load.
                  setTimeout(function () {
                    try {
                      if (window.__regraphMainLoaded || isMounted()) return;
                      injectModuleScript(src, "after_probe");
                    } catch (e) {
                      // ignore
                    }
                  }, 1200);
                })
                .catch(function (err) {
                  clearTimeout(t);
                  if (window.__regraphMainLoaded) return;

                  var msg = String((err && err.message) || err || "fetch_error");
                  var isAbort =
                    timedOut ||
                    (err && err.name === "AbortError") ||
                    msg.toLowerCase().indexOf("aborted") !== -1;

                  // If the probe times out, do NOT reload. Let the original <script type="module">
                  // continue loading; otherwise we'll keep interrupting a slow-but-valid connection.
                  if (isAbort) {
                    sendBootEvent("main_not_started", {
                      stage: "progress",
                      probe: "entry_fetch_timeout",
                      via: found ? found.via : "unknown",
                      entrySrc: src,
                      message: msg,
                      timeoutMs: PROBE_TIMEOUT_MS,
                    });
                    return;
                  }

                  sendBootEvent("main_not_started", {
                    stage: "progress",
                    probe: "entry_fetch_error",
                    via: found ? found.via : "unknown",
                    entrySrc: src,
                    message: msg,
                  });
                  reloadOnce("entry_fetch_error");
                });
            } catch (e) {
              // ignore
            }
          })();
        }, 2500);

        function reloadOnce(triggerReason) {
          if (hasReloadMarker()) return;
          var u = safeUrl();
          if (!u) return;

          try {
            sendBootEvent("reload_once", { stage: "reload", trigger: String(triggerReason || "unknown") });
          } catch (e) {}

          u.searchParams.set(RELOAD_PARAM, "1");
          u.searchParams.set("__reload", String(now()));

          try {
            window.location.replace(u.toString());
          } catch (e) {
            window.location.href = u.toString();
          }
        }

        // Record + heal recoverable module/chunk failures
        window.addEventListener("error", function (e) {
          var msg = (e && (e.message || (e.error && e.error.message))) || "unknown";
          record("error", msg);

          if (isRecoverableModuleError(msg)) {
            reloadOnce("error:" + msg);
          } else {
            // non-recoverable: log immediately so admins see it
            sendBootEvent("boot_error", { stage: "error", message: String(msg) });
          }
        });

        window.addEventListener("unhandledrejection", function (e) {
          var reason = (e && e.reason) || "unknown";
          var msg = reason && reason.message ? reason.message : String(reason);
          record("rejection", msg);

          if (isRecoverableModuleError(msg)) {
            reloadOnce("rejection:" + msg);
          } else {
            sendBootEvent("boot_rejection", { stage: "rejection", message: String(msg) });
          }
        });

        function showFatalScreen(reason) {
          removeSpinner();
          // Ensure we always have a Boot Event in persistent failures
          sendBootEvent(reason, { stage: "fatal" });

          try {
            if (document.getElementById("boot-fatal")) return;

            var box = document.createElement("div");
            box.id = "boot-fatal";
            box.setAttribute("role", "alert");
            box.style.cssText =
              "position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10000;padding:24px;background:rgba(0,0,0,0.92);color:#fff;font-family:system-ui,-apple-system,sans-serif;";

            var card = document.createElement("div");
            card.style.cssText =
              "max-width:480px;width:100%;border:1px solid rgba(255,255,255,0.15);border-radius:16px;padding:24px;background:rgba(18,18,18,0.98);";

            var h = document.createElement("div");
            h.textContent = "Loading taking too long";
            h.style.cssText = "font-weight:700;font-size:20px;margin-bottom:12px;";

            var p = document.createElement("div");
            p.innerHTML =
              "The app did not start. Try refreshing. If it keeps failing, something may be blocking JavaScript module loading on this network." +
              "<br/><br/>Open <a href=\"/asset-probe.html\" style=\"color:#c4b5fd\">/asset-probe.html</a> to see which asset request is failing.";
            p.style.cssText = "line-height:1.5;font-size:14px;opacity:0.85;margin-bottom:16px;";

            var btn = document.createElement("button");
            btn.type = "button";
            btn.textContent = "Refresh Page";
            btn.style.cssText =
              "appearance:none;border:0;border-radius:10px;padding:12px 20px;background:hsl(var(--primary));color:hsl(var(--primary-foreground));font-weight:600;font-size:15px;cursor:pointer;";
            btn.onclick = function () {
              window.location.reload();
            };

            card.appendChild(h);
            card.appendChild(p);
            card.appendChild(btn);
            box.appendChild(card);
            document.body.appendChild(box);
          } catch (e) {
            removeSpinner();
          }
        }

        // After 15s without mount, emit a "slow" boot event so admins can see it.
        setTimeout(function () {
          if (!isMounted()) {
            sendBootEvent("slow_mount", { stage: "progress" });
          }
        }, SLOW_LOG_MS);

        // After 60s, show fatal UI (no infinite spinner).
        setTimeout(function () {
          if (!isMounted()) showFatalScreen("deadline");
        }, FATAL_DEADLINE_MS);
      })();
    </script>

    <style>
      /* Boot spinner styles - shown until React mounts */
      :root{
        --primary:270 80% 60%;
        --boot-bg:240 10% 4%;
      }
      body{margin:0;background:hsl(var(--boot-bg));}
      #boot-spinner{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:9999;background:hsl(var(--boot-bg));}
      #boot-spinner:before{content:"";width:24px;height:24px;border-radius:999px;border:2px solid hsl(var(--primary) / 0.2);border-top-color:hsl(var(--primary));animation:bootspin 900ms linear infinite;}
      @keyframes bootspin{to{transform:rotate(360deg);}}
    </style>
  </body>
</html>
