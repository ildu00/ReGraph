<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Asset Probe ‚Äì Deep Check</title>
    <meta name="robots" content="noindex, nofollow" />
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; padding: 16px; font-family: ui-sans-serif, system-ui, -apple-system, sans-serif; background: #0b0b0d; color: #eaeaf2; font-size: 13px; }
      h1 { margin: 0 0 8px; font-size: 18px; }
      p { margin: 0 0 12px; opacity: 0.8; font-size: 12px; }
      .card { max-width: 900px; border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 16px; background: rgba(255,255,255,0.03); }
      .row { display: grid; grid-template-columns: 200px 1fr; gap: 8px; padding: 8px 0; border-top: 1px solid rgba(255,255,255,0.08); }
      .row:first-child { border-top: 0; }
      .k { font-size: 11px; opacity: 0.7; }
      .v { font-family: ui-monospace, monospace; font-size: 11px; white-space: pre-wrap; word-break: break-word; }
      .ok { color: #8ef0a3; }
      .bad { color: #ff8a8a; }
      .warn { color: #facc15; }
      .nested { margin-left: 12px; padding-left: 8px; border-left: 2px solid #333; font-size: 10px; }
      button { appearance: none; border: 0; border-radius: 10px; padding: 10px 14px; background: #6d28d9; color: #fff; font-weight: 700; cursor: pointer; margin-top: 12px; }
      #status { padding: 8px; background: #1a1a1a; border-radius: 8px; margin-bottom: 12px; font-size: 12px; }
    </style>
  </head>
  <body>
    <div class="card">
      <h1>üî¨ Asset Probe ‚Äì Deep Dependency Check</h1>
      <p>Fetches entry module, extracts all nested imports (2 levels), and verifies each returns JS (not HTML/404).</p>
      <div id="status">Initializing...</div>
      <div id="out"></div>
      <button id="run">Re-run probe</button>
    </div>

    <script>
      const out = document.getElementById("out");
      const status = document.getElementById("status");
      const btn = document.getElementById("run");

      const setStatus = (s) => { status.textContent = s; };

      const addRow = (k, v, cls = "") => {
        const row = document.createElement("div");
        row.className = "row";
        row.innerHTML = `<div class="k">${k}</div><div class="v ${cls}">${v}</div>`;
        out.appendChild(row);
        return row;
      };

      const fetchAsset = async (url, timeout = 10000) => {
        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), timeout);
        try {
          const res = await fetch(url, { cache: "no-store", signal: controller.signal });
          const ct = res.headers.get("content-type") || "";
          const text = await res.text();
          return { url, status: res.status, ct, text, ok: res.ok };
        } catch (e) {
          return { url, status: 0, ct: "", text: "", ok: false, error: e.message };
        } finally {
          clearTimeout(t);
        }
      };

      // Extract import statements from minified JS
      const extractImports = (code) => {
        const imports = new Set();
        // Static: import ... from "..."
        const staticRe = /from\s*["']([^"']+)["']/g;
        let m;
        while ((m = staticRe.exec(code))) imports.add(m[1]);
        // Dynamic: import("...")
        const dynRe = /import\s*\(\s*["']([^"']+)["']\s*\)/g;
        while ((m = dynRe.exec(code))) imports.add(m[1]);
        return Array.from(imports);
      };

      // Resolve relative path against base
      const resolvePath = (base, rel) => {
        if (rel.startsWith("/") || rel.startsWith("http")) return rel;
        if (!rel.startsWith(".")) return null; // bare specifier, skip
        const baseParts = base.split("/").slice(0, -1);
        for (const part of rel.split("/")) {
          if (part === "..") baseParts.pop();
          else if (part !== ".") baseParts.push(part);
        }
        return baseParts.join("/");
      };

      const run = async () => {
        out.innerHTML = "";
        setStatus("Fetching index.html...");

        addRow("URL", location.href);
        addRow("UA", navigator.userAgent);
        addRow("Time", new Date().toISOString());

        // 1) Fetch HTML
        const html = await fetchAsset("/");
        addRow("GET /", `${html.status} | ${html.ct}`, html.ok ? "ok" : "bad");

        const entryMatch = html.text.match(/<script[^>]*type="module"[^>]*src="([^"]+)"/i);
        const entrySrc = entryMatch ? entryMatch[1] : null;
        addRow("Entry module", entrySrc || "NOT FOUND", entrySrc ? "" : "bad");
        if (!entrySrc) { setStatus("Done ‚Äì no entry"); return; }

        // 2) Fetch entry
        setStatus("Fetching entry module...");
        const entry = await fetchAsset(entrySrc);
        addRow("Entry status", `${entry.status} | ${entry.ct}`, entry.ok ? "ok" : "bad");
        if (!entry.ok) { setStatus("Done ‚Äì entry failed"); return; }

        // 3) Extract L1 deps
        const l1Imports = extractImports(entry.text);
        const l1Assets = l1Imports.map(i => resolvePath(entrySrc, i)).filter(p => p && p.startsWith("/assets/"));
        addRow("Entry ‚Üí L1 deps", l1Assets.length + " asset imports found");

        const analyzed = new Set([entrySrc]);
        const problems = [];

        // 4) Fetch each L1 dep and check L2
        for (const l1 of l1Assets) {
          if (analyzed.has(l1)) continue;
          analyzed.add(l1);

          setStatus(`Checking ${l1}...`);
          const r1 = await fetchAsset(l1);
          const isJs = r1.ct.includes("javascript");
          const isHtml = r1.ct.includes("text/html");
          const l1Ok = r1.ok && isJs && !isHtml;

          const row = addRow(l1, `${r1.status} | ${r1.ct}`, l1Ok ? "ok" : (isHtml ? "warn" : "bad"));

          if (!l1Ok) {
            problems.push({ url: l1, status: r1.status, ct: r1.ct });
          }

          // L2: nested imports
          if (l1Ok) {
            const l2Imports = extractImports(r1.text);
            const l2Assets = l2Imports.map(i => resolvePath(l1, i)).filter(p => p && p.startsWith("/assets/") && !analyzed.has(p));

            if (l2Assets.length > 0) {
              const nested = document.createElement("div");
              nested.className = "nested";
              row.appendChild(nested);

              for (const l2 of l2Assets.slice(0, 6)) {
                analyzed.add(l2);
                setStatus(`Checking ${l2}...`);
                const r2 = await fetchAsset(l2);
                const l2Ok = r2.ok && r2.ct.includes("javascript");
                nested.innerHTML += `<div class="${l2Ok ? 'ok' : 'bad'}">‚Ü≥ ${l2}: ${r2.status} | ${r2.ct}</div>`;
                if (!l2Ok) problems.push({ url: l2, status: r2.status, ct: r2.ct, parent: l1 });
              }
              if (l2Assets.length > 6) {
                nested.innerHTML += `<div>... +${l2Assets.length - 6} more</div>`;
              }
            }
          }
        }

        // Summary
        if (problems.length > 0) {
          addRow("‚ö†Ô∏è PROBLEMS", JSON.stringify(problems, null, 1), "bad");
          setStatus(`Done ‚Äì ${problems.length} problem(s) found!`);
        } else {
          addRow("‚úÖ Result", "All dependencies (L1+L2) loaded with correct JS content-type.", "ok");
          addRow("Next", "Assets load OK via fetch(). Issue may be Safari module parsing or content blocker. Try:\n1) Clear Safari cache fully\n2) Disable content blockers\n3) Test in Chrome/Firefox on same device", "");
          setStatus("Done ‚Äì all assets OK");
        }
      };

      btn.addEventListener("click", run);
      run();
    </script>
  </body>
</html>
